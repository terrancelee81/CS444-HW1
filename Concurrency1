/* Concurrency 1: The Producer-Consumer Problem
 * Group: 10-11
 * CS444
 */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>

#include "mt.h"

/* Buffer can hold up to 32 items */
#define BUFF_MAX 32

/* Item has a number for printing and a number for sleeping */
struct item {
	int print_num;
	int sleep_time;
};

/* Buffer, buffer count, and buffer mutex */
struct item buffer[BUFF_MAX];
int buff_count = 0;
pthread_mutex_t buff_mutex = PTHREAD_MUTEX_INITIALIZER;

/* Functions for manipulating buffer */
void buff_push(struct item buff_item);
struct item buff_pop(void);
int buff_empty(void);
int buff_full(void);
void buff_lock(void);
void buff_unlock(void);

/* Consumer and producer functions */
void *consumer(void *arg);
void *producer(void);

/* Functions for getting a random number */
int get_rand(void);
int get_rdrand(void);

void buff_push(struct item buff_item)
{
	buffer[buff_count++] = buff_item;
}

struct item buff_pop(void)
{
	return buffer[--buff_count];
}

int buff_empty(void)
{
	return buff_count <= 0;
}

int buff_full(void)
{
	return buff_count >= 32;
}

void buff_lock(void)
{
	pthread_mutex_lock(&buff_mutex);
}

void buff_unlock(void)
{
	pthread_mutex_unlock(&buff_mutex);
}

void *consumer(void *arg)
{
	while(1) {
		buff_lock();
		puts("consumer locked");
		if (buff_empty()) {
			buff_unlock();
			puts("consumer unlocked");
			continue;
		}
		
		struct item buff_item = buff_pop();
		sleep(buff_item.sleep_time);
		printf("%d", buff_item.print_num);
		
		buff_unlock();
		puts("consumer unlocked");
	}
}

void *producer(void)
{
	struct item buff_item;
	
	while(1) {
		buff_lock();
		puts("producer locked");
		if (buff_full()) {
			buff_unlock();
			puts("producer unlocked");
			continue;
		}
		
		sleep(get_rand() % 5 + 3);
		buff_item.print_num = get_rand() % RAND_MAX;
		buff_item.sleep_time = get_rand() % 8 + 2;
		buff_push(buff_item);
		
		buff_unlock();
		puts("producer unlocked");
	}
}

int get_rand(void)
{
	unsigned int eax;
	unsigned int ecx;
	
	eax = 0x01;

	__asm__ __volatile__(
			"cpuid;"
			: "=c"(ecx)
			: "a"(eax)
			);
	
	if(ecx & 0x40000000)
		return get_rdrand();
	else
		return genrand_int32();
}

int get_rdrand(void)
{
	unsigned int rand_num;
	
	__asm__ __volatile__(
			"rdrand %0"
			: "=r"(rand_num)
			);
	
	return rand_num;
}

int main(int argc, char **argv)
{
	/* Seed Mersenne Twister */
	unsigned long init[4] = {0x123, 0x234, 0x345, 0x456};
	unsigned long length = 4;
	init_by_array(init, length);
	
	int get_rand();
	
	/* Number of consumer threads specified by user */
	int num_threads = atoi(argv[1]);
	pthread_t threads[num_threads];
	
	/* Create consumer threads */
	int i;
	for (i = 0; i < num_threads; i++)
		pthread_create(&(threads[i]), NULL, consumer, NULL);
	
	/* Producer thread */
   for (i = 0; i < num_threads; i++)
		pthread_create(&(threads[i], NULL, producer, NULL);
	
	return 0;
}
